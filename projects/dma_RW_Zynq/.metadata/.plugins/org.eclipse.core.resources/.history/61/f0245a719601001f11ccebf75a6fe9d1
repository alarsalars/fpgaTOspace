
/*
 *
 *
 *
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "xaxidma.h"
#include "xparameters.h"
#include "sleep.h"
#include "xil_cache.h"

//typedef uint32_t u32; // Assuming u32 is an unsigned 32-bit integer type
u32 checkHalted(u32 baseAddress,u32 offset);

int main(){


	dchar *file_path = "C:\Users\TAlars\Documents\vivado_projects_tests\vipix\dma\dma_RW_Zynq\dma_zubaord\src\boot.bin";
    // Step 1: Open the binary file
    FILE *file = fopen(file_path, "rb");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }
    // Step 2: Determine the size of the file
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);
    // Step 3: Allocate memory for data1[] based on file size
    u32 *a = (u32 *)malloc(file_size);
    if (a == NULL) {
        perror("Memory allocation failed");
        fclose(file);
        return 1;
    }
    // Step 4: Read the binary data into data1[]
    size_t elements_read = fread(a, sizeof(u32), file_size / sizeof(u32), file);
    if (elements_read != file_size / sizeof(u32)) {
        perror("Error reading file");
        fclose(file);
        free(a);
        return 1;
    }

    // Step 5: Close the file after reading
    fclose(file);
    // Step 6: Create data2[] of the same size as data1[] (but initialized to zeros)
    u32 *b = (u32 *)calloc(file_size / sizeof(u32), sizeof(u32));
    if (b == NULL) {
        perror("Memory allocation failed");
        free(a);
        return 1;
    }

    u32 status;

	XAxiDma_Config *myDmaConfig;
	XAxiDma myDma;

	myDmaConfig = XAxiDma_LookupConfigBaseAddr(XPAR_AXI_DMA_0_BASEADDR);
	status = XAxiDma_CfgInitialize(&myDma, myDmaConfig);
	if(status != XST_SUCCESS){
		print("DMA initialization failed\n");
		return -1;
	}
	print("DMA initialization success..\n");
	status = checkHalted(XPAR_AXI_DMA_0_BASEADDR,0x4);
	xil_printf("Status before data transfer %0x\n",status);
	Xil_DCacheFlushRange((u32)a,elements_read*sizeof(u32));
	Xil_DCacheFlushRange((u32)b,elements_read*sizeof(u32));
	status = XAxiDma_SimpleTransfer(&myDma, (u32)b, elements_read*sizeof(u32),XAXIDMA_DEVICE_TO_DMA);
	status = XAxiDma_SimpleTransfer(&myDma, (u32)a, elements_read*sizeof(u32),XAXIDMA_DMA_TO_DEVICE);
	if(status != XST_SUCCESS){
		print("DMA initialization failed\n");
		return -1;
	}
    status = checkHalted(XPAR_AXI_DMA_0_BASEADDR,0x4);
    while(status != 1){
    	status = checkHalted(XPAR_AXI_DMA_0_BASEADDR,0x4);
    }
    status = checkHalted(XPAR_AXI_DMA_0_BASEADDR,0x34);
    while(status != 1){
    	status = checkHalted(XPAR_AXI_DMA_0_BASEADDR,0x34);
    }
	print("DMA transfer success..\n");
	print("write..\n");
	for(int i=0;i<elements_read;i++)
			xil_printf("%0x\n",a[i]);
	print("read..\n");

	for(int i=0;i<elements_read;i++)
		xil_printf("%0x\n",b[i]);

    // Step 8: Clean up - free allocated memory
    free(a);
    free(b);
}


u32 checkHalted(u32 baseAddress,u32 offset){
	u32 status;
	status = (XAxiDma_ReadReg(baseAddress,offset))&XAXIDMA_HALTED_MASK;
	return status;
}
